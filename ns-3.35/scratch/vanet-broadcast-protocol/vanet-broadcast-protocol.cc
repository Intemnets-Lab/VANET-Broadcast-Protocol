#include "vanet-broadcast-protocol.h"
#include "ns3/udp-l4-protocol.h"

namespace ns3
{
  NS_LOG_COMPONENT_DEFINE("VanetBroadcastProtocol");

  namespace vbp
  {
    NS_OBJECT_ENSURE_REGISTERED(RoutingProtocol);
    const uint8_t RoutingProtocol::PROT_NUMBER = 253;
    const uint8_t RoutingProtocol::UDP_PROT_NUMBER = 17;
    const uint32_t RoutingProtocol::VBP_HELLO_PORT = 655;
    const uint32_t RoutingProtocol::VBP_DATA_PORT = 8081;
    uint64_t m_uniformRandomVariable;
    const uint32_t Period_HelloTx = 95;
    const uint32_t Jitter_HelloTx = 10;

    /// Tag used by vbp implementation
    struct DeferredRouteOutputTag : public Tag
    {
      /// Positive if output device is fixed in RouteOutput
      int32_t oif;

      /**
       * Constructor
       *
       * \param o outgoing interface (OIF)
       */
      DeferredRouteOutputTag(int32_t o = -1)
          : Tag(),
            oif(o)
      {
      }

      /**
       * \brief Get the type ID.
       * \return the object TypeId
       */
      static TypeId
      GetTypeId()
      {
        static TypeId tid = TypeId("ns3::vbp::DeferredRouteOutputTag")
                                .SetParent<Tag>()
                                .SetGroupName("Vbp")
                                .AddConstructor<DeferredRouteOutputTag>();
        return tid;
      }

      TypeId
      GetInstanceTypeId() const
      {
        return GetTypeId();
      }

      uint32_t
      GetSerializedSize() const
      {
        return sizeof(int32_t);
      }

      void
      Serialize(TagBuffer i) const
      {
        i.WriteU32(oif);
      }

      void
      Deserialize(TagBuffer i)
      {
        oif = i.ReadU32();
      }

      void
      Print(std::ostream &os) const
      {
        os << "DeferredRouteOutputTag: output interface = " << oif;
      }
    };

    TypeId
    RoutingProtocol::GetTypeId(void)
    {
      static TypeId tid = TypeId("ns3::vbp::RoutingProtocol")
                              .SetParent<Ipv4RoutingProtocol>()
                              .SetGroupName("Vbp")
                              .AddConstructor<RoutingProtocol>();
      return tid;
    }

    RoutingProtocol::RoutingProtocol()
        : m_maxDistance(500),
          m_txCutoffPercentage(1),
          m_vcHighTraffic(0.8),
          m_vcLowTraffic(0.4),
          m_emptyQueuePeriod(0.5),
          m_BroadcastTime(1e9),
          m_routingTable(Time(5)),
          m_helloPacketType('h'),
          m_dataPacketType('d')
    {
      Ptr<VbpNeighbors> m_neighborsListPointer2 = CreateObject<VbpNeighbors>();
      m_neighborsListPointer->AggregateObject(m_neighborsListPointer2);
      m_broadcastArea[0] = NAN;
      m_broadcastArea[1] = NAN;
      m_broadcastArea[2] = NAN;
      m_broadcastArea[3] = NAN;
      Ptr<VbpQueue> m_queuePointer2 = CreateObject<VbpQueue>();
      m_queuePointer->AggregateObject(m_queuePointer2);
      ScheduleEmptyQueue();
    }

    RoutingProtocol::~RoutingProtocol()
    {
    }

    Ptr<Ipv4Route>
    RoutingProtocol::RouteOutput(Ptr<Packet> p, const Ipv4Header &header, Ptr<NetDevice> oif, Socket::SocketErrno &sockerr)
    {
      /*
        RouteOutput takes care of routing the packet's first hop after the packet is generated by the application placed on the source node
        First is a check of whether or not we have interfaces for nodes available. This will return an error if nodes are not created in the simulation script
        Then the packet is filled with vbp data through routingHeader
        If FindFirstHop() returns true SetSendFirstHop() is called. This shows that a first hop is available and Ipv4L3Protocol is used to send the packet to the next hop
      */
      NS_LOG_FUNCTION(this);
      Ptr<Ipv4Route> route;
      if (m_socketAddresses.empty())
      {
        sockerr = Socket::ERROR_NOROUTETOHOST;
        NS_LOG_LOGIC("No vbp interfaces");
        return route;
      }
      sockerr = Socket::ERROR_NOTERROR;
      VbpRoutingHeader routingHeader;
      RoutingTableEntry rt;
      Ipv4Address dst = header.GetDestination();
      Ipv4Address src = header.GetSource();
      Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      Ipv4Address origin = iface.GetAddress();
      Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
      routingHeader.SetData(m_dataPacketType, origin, m_broadcastArea[0], m_broadcastArea[1], m_broadcastArea[2], m_broadcastArea[3], m_BroadcastTime);
      p->AddHeader(routingHeader);
      Ipv4Address nextHopAhead;
      Ipv4Address nextHopBehind;
      NS_LOG_LOGIC("Route Output Packet Type: " << routingHeader.GetPacketType());
      if (FindFirstHop(&nextHopAhead, &nextHopBehind)) // find next hop
      {
        NS_LOG_LOGIC("Sender FindFirstHop: " << iface.GetAddress());
        NS_LOG_LOGIC("Send First Hop - Ahead " << nextHopAhead << " Behind " << nextHopBehind);
        // if (iface.GetAddress() == Ipv4Address("10.1.1.1") && nextHopAhead == Ipv4Address("10.1.1.6"))
        // {
        //   std::cout << "SRC N0 DST N20 Towards BA: Sender & Receiver Test PASSED" << std::endl;
        // }
        // if (iface.GetAddress() == Ipv4Address("10.1.1.21") && nextHopBehind == Ipv4Address("10.1.1.16"))
        // {
        //   std::cout << "SRC N21 DST N0 AWAY BA: Sender & Receiver Test PASSED" << std::endl;
        // }
        // if (iface.GetAddress() == Ipv4Address("10.1.1.11") && nextHopAhead == Ipv4Address("10.1.1.16"))
        // {
        //   std::cout << "SRC N10 DST N0/N21 TOWARDS BA: Sender & Receiver Test PASSED" << std::endl;
        // }
        SetSendFirstHop(&nextHopAhead, &nextHopBehind, p, dev, iface, src, dst);
      }
      else
      {
        NS_LOG_LOGIC("Else Case: Send First Hop - Ahead " << nextHopAhead << " Behind " << nextHopBehind);
        // Valid route not found, return loopback
        uint32_t iif = (oif ? m_ipv4->GetInterfaceForDevice(oif) : -1);
        DeferredRouteOutputTag tag(iif);
        NS_LOG_DEBUG("Valid Route not found");
        if (!p->PeekPacketTag(tag))
        {
          p->AddPacketTag(tag);
        }
        route = LoopbackRoute(header, oif);
      }
      return route;
    }

    bool
    RoutingProtocol::RouteInput(Ptr<const Packet> p, const Ipv4Header &header,
                                Ptr<const NetDevice> idev, UnicastForwardCallback ucb,
                                MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)
    {
      /*
      RouteInput() takes care of receiving packets from the previous hop and transmitting packets to the next hop. 
      LCB is a callback for packets to be locally delivered. It is necessary to include lcb when modifying or creating a routing protocol
      We ensure that we are dealing with vbp data packets by checking that the protocol number.
      It can be confirmed if a packet is delivered at a specific node IP address through the log 'local delivery at'
      */
      NS_LOG_FUNCTION(this);
      if (m_socketAddresses.empty())
      {
        NS_LOG_LOGIC("No vbp interfaces");
        return false;
      }
      NS_ASSERT(m_ipv4 != 0);
      NS_ASSERT(p != 0);
      // Check if input device supports IP
      NS_ASSERT(m_ipv4->GetInterfaceForDevice(idev) >= 0);
      int32_t iif = m_ipv4->GetInterfaceForDevice(idev);
      Ipv4Address dst = header.GetDestination();
      Ipv4Address src = header.GetSource();
      // Deferred route request
      if (idev == m_lo)
      {
        DeferredRouteOutputTag tag;
        if (p->PeekPacketTag(tag))
        {
          DeferredRouteOutput(p, header, ucb, ecb);
          return false;
          // return true;
        }
      }
      // VBP is not a multicast routing protocol
      if (dst.IsMulticast())
      {
        NS_LOG_LOGIC("Multicast Return False");
        return false;
      }
      Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      // Unicast local delivery
      if (m_ipv4->IsDestinationAddress(dst, iif))
      {
        if (lcb.IsNull() == false)
        {
          NS_LOG_LOGIC("Unicast local delivery to " << dst);
          uint8_t protocol_numb = header.GetProtocol();
          if (protocol_numb == PROT_NUMBER)
          {
            NS_LOG_LOGIC("Protocol Number = 253, VBP Data Packet at " << iface.GetLocal());
            bool packetSentIndicator = false;
            Ptr<Packet> q = p->Copy();
            bool lcbIndicator = RoutePacket(q, dst, src, &packetSentIndicator); // true lcb. false no lcb
            if (lcbIndicator)
            {
              NS_LOG_LOGIC("local delivery at " << iface.GetLocal());
              UdpHeader udpHead;
              udpHead.SetDestinationPort(VBP_DATA_PORT); //8081
              udpHead.SetSourcePort(VBP_DATA_PORT); //8081
              udpHead.InitializeChecksum(header.GetSource(), header.GetDestination(), PROT_NUMBER);
              q->AddHeader(udpHead);
              Ipv4Header headerCopy;
              headerCopy.SetDestination(header.GetDestination());
              headerCopy.SetDscp(header.GetDscp());
              headerCopy.SetEcn(header.GetEcn());
              headerCopy.SetIdentification(header.GetIdentification());
              headerCopy.SetPayloadSize(header.GetPayloadSize());
              headerCopy.SetProtocol(UDP_PROT_NUMBER); //17
              headerCopy.SetSource(header.GetSource());
              headerCopy.SetTos(header.GetTos());
              headerCopy.SetTtl(header.GetTtl());
              lcb(q, headerCopy, iif);
            }
            return true;
          }
          lcb(p, header, iif); // non-vbp-data-packet local callback
        }
        else
        {
          NS_LOG_ERROR("Unable to deliver packet locally due to null callback " << p->GetUid() << " from " << src);
          ecb(p, header, Socket::ERROR_NOROUTETOHOST);
        }
        return true;
      }
      NS_LOG_LOGIC("Forwarding Error in RouteInput ");
      NS_LOG_ERROR("Unable to forward packet due to not being a VANET Broadcast Protocol data packet " << p->GetUid() << " from " << src);
      ecb(p, header, Socket::ERROR_NOROUTETOHOST);
      return false;
    }

    void
    RoutingProtocol::NotifyInterfaceUp(uint32_t interface)
    {
      /*
       Protocols are expected to implement this method to be notified of the state change of an interface in a node.
      */
      NS_LOG_FUNCTION(this);
      if (interface > 1)
      {
        NS_LOG_WARN("VBP does not work with more then one interface.");
      }
      Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
      if (l3->GetNAddresses(interface) > 1)
      {
        NS_LOG_WARN("VBP does not work with more then one address per each interface.");
      }
      Ipv4InterfaceAddress iface = l3->GetAddress(interface, 0);
      if (iface.GetLocal() == Ipv4Address("127.0.0.1"))
      {
        return;
      }
      // include check that m_socketaddresses is empty and m_socketSubnetBroadcastAddresses is empty. Print out message only one interface is allowed if check fails
      //  Create a socket to listen only on this interface
      Ptr<Socket> socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
      NS_ASSERT(socket != 0);
      socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvVbp, this));
      socket->BindToNetDevice(l3->GetNetDevice(interface));
      socket->Bind(InetSocketAddress(iface.GetLocal(), VBP_HELLO_PORT));
      socket->SetAllowBroadcast(true);
      socket->SetIpRecvTtl(true);
      m_socketAddresses.insert(std::make_pair(socket, iface));

      // create also a subnet broadcast socket
      socket = Socket::CreateSocket(GetObject<Node>(), UdpSocketFactory::GetTypeId());
      NS_ASSERT(socket != 0);
      socket->SetRecvCallback(MakeCallback(&RoutingProtocol::RecvVbp, this));
      socket->BindToNetDevice(l3->GetNetDevice(interface));
      socket->Bind(InetSocketAddress(iface.GetBroadcast(), VBP_HELLO_PORT));
      socket->SetAllowBroadcast(true);
      socket->SetIpRecvTtl(true);
      m_socketSubnetBroadcastAddresses.insert(std::make_pair(socket, iface));

      NS_LOG_LOGIC(Simulator::Now().GetSeconds() << " Seconds --- "
                                                    << "NotifyInterfaceUp "
                                                    << "--- " << m_ipv4->GetNInterfaces() << " Interfaces");

      m_thisNode = socket->GetNode();
      NS_LOG_LOGIC("This Node: " << m_thisNode->GetObject<MobilityModel>()->GetPosition());
      m_neighborsListPointer->GetObject<VbpNeighbors>()->SetThisNode(m_thisNode);
    }

    void
    RoutingProtocol::NotifyInterfaceDown(uint32_t interface)
    {
      /*
       Protocols are expected to implement this method to be notified of the state change of an interface in a node.
      */
      NS_LOG_FUNCTION(this << m_ipv4->GetAddress(interface, 0).GetLocal());
    }

    void
    RoutingProtocol::NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)
    {
      /*
      Protocols are expected to implement this method to be notified whenever a new address is added from an interface.
      */
      NS_LOG_FUNCTION(this << " interface " << interface << " address " << address);
      Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();

      if (!l3->IsUp(interface))
      {
        return;
      }
    }

    void
    RoutingProtocol::NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)
    {
      /*
      Protocols are expected to implement this method to be notified whenever a new address is removed from an interface.
      */
      NS_LOG_FUNCTION(this);
    }

    void
    RoutingProtocol::RecvVbp(Ptr<Socket> socket)
    {
      /*
      Receive and process the control (hello) packet.
      Obtain information from hello packets in this function, as shown in the log functions
      */
      NS_LOG_FUNCTION(this);
      Address sourceAddress;
      Ptr<Packet> packet = socket->RecvFrom(sourceAddress);
      InetSocketAddress inetSourceAddr = InetSocketAddress::ConvertFrom(sourceAddress);
      Ipv4Address sender = inetSourceAddr.GetIpv4();
      Ipv4Address receiver;

      if (m_socketAddresses.find(socket) != m_socketAddresses.end())
      {
        receiver = m_socketAddresses[socket].GetLocal();
      }
      else if (m_socketSubnetBroadcastAddresses.find(socket) != m_socketSubnetBroadcastAddresses.end())
      {
        receiver = m_socketSubnetBroadcastAddresses[socket].GetLocal();
      }
      else
      {
        NS_ASSERT_MSG(false, "Received a packet from an unknown socket");
      }
      // remove the header from the packet:
      VbpHelloHeader destinationHeader;
      packet->PeekHeader(destinationHeader);
      NS_LOG_LOGIC("---Tx From --- " << sender);
      NS_LOG_LOGIC("---Tx To --- " << receiver);
      NS_LOG_LOGIC("---Begin Control Header Information --- ");
      NS_LOG_LOGIC("Packet Type: " << destinationHeader.GetPacketType());
      NS_LOG_LOGIC("Position X: " << destinationHeader.GetPositionX());
      NS_LOG_LOGIC("Position Y: " << destinationHeader.GetPositionY());
      NS_LOG_LOGIC("Speed X: " << destinationHeader.GetSpeedX());
      NS_LOG_LOGIC("Speed Y: " << destinationHeader.GetSpeedY());
      // std::cout << "Tx from: " << sender << std::endl;
      // std::cout << "Tx to: " << receiver << std::endl;
      // std::cout << "---Begin Control Header Information---" << std::endl;
      // std::cout << "Packet type: " << destinationHeader.GetPacketType() << std::endl;
      // std::cout << "Position X [m]: " << destinationHeader.GetPositionX() << std::endl;
      // std::cout << "Position Y [m]: " << destinationHeader.GetPositionY() << std::endl;
      // std::cout << "Speed X [m/s]:" << destinationHeader.GetSpeedX()  << std::endl;
      // std::cout << "Speed Y [m/s]:" << destinationHeader.GetSpeedY()  << std::endl;
      // std::cout << "Number of neighbors ahead: " << destinationHeader.GetNumNeighborsAhead()  << std::endl;
      // std::cout << "Number of neighbors behind: " << destinationHeader.GetNumNeighborsBehind()  << std::endl;
      // std::cout << "Neighbor furthest ahead X-Pos [m]: " << destinationHeader.GetNeighborFurthestAheadX()  << std::endl;
      // std::cout << "Neighbor furthest ahead Y-Pos [m]: " << destinationHeader.GetNeighborFurthestAheadY()  << std::endl;
      // std::cout << "Neighbor furthest behind X-Pos [m]: " << destinationHeader.GetNeighborFurthestBehindX()  << std::endl;
      // std::cout << "Neighbor furthest behind Y-Pos [m]: " << destinationHeader.GetNeighborFurthestBehindY()  << std::endl;
      // std::cout << "Average speed X [m/s]: " << destinationHeader.GetAvgSpeedX()  << std::endl;
      // std::cout << "Average speed Y [m/s]: " << destinationHeader.GetAvgSpeedY()  << std::endl;
      // std::cout << "---End Control Header Information---" << std::endl;
      NS_LOG_LOGIC("---End Control Header Information --- ");
      if (destinationHeader.GetPacketType() == m_helloPacketType)
      {
        RecvHello(packet, receiver, sender);
        NS_LOG_LOGIC("Neighbors List: " << "Receiver " << receiver << " Sender " << sender << " Packet type: " << destinationHeader.GetPacketType());
       // m_neighborsListPointer->GetObject<VbpNeighbors>()->PrintNeighbors2();
      }
    }

    void
    RoutingProtocol::RecvHello(Ptr<Packet> p, Ipv4Address receiver, Ipv4Address sender)
    {
      VbpHelloHeader helloHeader;
      p->PeekHeader(helloHeader);
      // determine if forwarding node is ahead=1 or behind=0 by using dot product
      float dotProduct;
      float dotProductVel;
      Vector receiveNodePos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
      Vector diff = Vector3D(helloHeader.GetPositionX(), helloHeader.GetPositionY(), 0) - receiveNodePos; // vector pointing from receiving node to forwarding node
      Vector receiveNodeVelocity = m_thisNode->GetObject<MobilityModel>()->GetVelocity();

      if (receiveNodeVelocity.GetLength() == 0)
      {
        // if receiving node not moving, don't process anymore
        return;
      }

      dotProductVel = receiveNodeVelocity.x * helloHeader.GetSpeedX() + receiveNodeVelocity.y * helloHeader.GetSpeedY();
      if (dotProductVel <= 0)
      {
        // if velocity vectors do not align, don't process because neighbor moving in opposite direction
        return;
      }

      dotProduct = receiveNodeVelocity.x * diff.x + receiveNodeVelocity.y * diff.y;
      uint16_t direction; // 0 = behind, 1 = ahead
      if (dotProduct >= 0)
      {
        // if dot product positive, then ahead
        direction = 1;
      }
      else
      {
        // if dot product negative, then behind
        direction = 0;
      }

      // use received packet to update neighbors information in object neighbors
      // will add node as new neighbor or update information for that neighbor
      m_neighborsListPointer->GetObject<VbpNeighbors>()->AddNode(sender,
                                                                 direction,
                                                                 helloHeader.GetNumNeighborsAhead(),
                                                                 helloHeader.GetNumNeighborsBehind(),
                                                                 helloHeader.GetPositionX(),
                                                                 helloHeader.GetPositionY(),
                                                                 helloHeader.GetSpeedX(),
                                                                 helloHeader.GetSpeedY(),
                                                                 helloHeader.GetNeighborFurthestAheadX(),
                                                                 helloHeader.GetNeighborFurthestAheadY(),
                                                                 helloHeader.GetNeighborFurthestBehindX(),
                                                                 helloHeader.GetNeighborFurthestBehindY(),
                                                                 helloHeader.GetAvgSpeedX(),
                                                                 helloHeader.GetAvgSpeedY());
      // order is neighbor's node Id, direction, numAhead, numBehind, X, Y, speedX, speedY, furthestAhead.x, furthestAhead.y, furthestBehind.x
      // , furthestBehind.y, avg SpeedX, avgSpeedY
    }

    void
    RoutingProtocol::SetIpv4(Ptr<Ipv4> ipv4)
    {
      NS_ASSERT(ipv4 != 0);

      m_ipv4 = ipv4; // m_ipv4 set here

      // Create lo route. It is asserted that the only one interface up for now is loopback
      NS_ASSERT(m_ipv4->GetNInterfaces() == 1 && m_ipv4->GetAddress(0, 0).GetLocal() == Ipv4Address("127.0.0.1"));
      m_lo = m_ipv4->GetNetDevice(0);
      NS_ASSERT(m_lo != 0);
      return;
    }

    void
    RoutingProtocol::PrintRoutingTable(Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
    {
      *stream->GetStream() << "Node: " << m_ipv4->GetObject<Node>()->GetId()
                           << "; Time: " << Now().As(unit)
                           << ", Local time: " << m_ipv4->GetObject<Node>()->GetLocalTime().As(unit)
                           << ", VBP Routing table" << std::endl;

      m_routingTable.Print(stream, unit);
      *stream->GetStream() << std::endl;
    }

    void
    RoutingProtocol::SendHello()
    {
      NS_LOG_FUNCTION(this);
      for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
      {

        Ptr<Socket> socket = j->first;
        Ipv4InterfaceAddress iface = j->second;
        Ptr<Packet> packet = Create<Packet>();
        // create header here
        VbpHelloHeader HelloHeader;

        // get info needed in packet from sockets
        Vector pos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
        Vector vel = m_thisNode->GetObject<MobilityModel>()->GetVelocity();
        // set dummy values to header setData (pass hardcoded values)
        Vector furthestAhead = Vector3D(NAN, NAN, 0);
        int furthestIdxAhead = m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborFurthestAheadByIndex(pos);
        if (furthestIdxAhead >= 0)
        {
          furthestAhead = Vector3D(m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborPositionX(furthestIdxAhead), m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborPositionY(furthestIdxAhead), 0);
        }
        Vector furthestBehind = Vector3D(NAN, NAN, 0);
        int furthestIdxBehind = m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborFurthestBehindByIndex(pos);
        if (furthestIdxBehind >= 0)
        {
          furthestBehind = Vector3D(m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborPositionX(furthestIdxBehind), m_neighborsListPointer->GetObject<VbpNeighbors>()->GetNeighborPositionY(furthestIdxBehind), 0);
        }
        HelloHeader.SetData(m_helloPacketType,
                            pos.x,
                            pos.y,
                            vel.x,
                            vel.y,
                            m_neighborsListPointer->GetObject<VbpNeighbors>()->Get1HopNumNeighborsAhead(),
                            m_neighborsListPointer->GetObject<VbpNeighbors>()->Get1HopNumNeighborsBehind(),
                            furthestAhead.x,
                            furthestAhead.y,
                            furthestBehind.x,
                            furthestBehind.y,
                            m_neighborsListPointer->GetObject<VbpNeighbors>()->GetAvgSpeedNeighborX(vel.x),
                            m_neighborsListPointer->GetObject<VbpNeighbors>()->GetAvgSpeedNeighborY(vel.y));

        // add header to packet
        packet->AddHeader(HelloHeader);

        // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise
        Ipv4Address destination;
        if (iface.GetMask() == Ipv4Mask::GetOnes())
        {
          destination = Ipv4Address("255.255.255.255");
        }
        else
        {
          destination = iface.GetBroadcast();
        }
        Time jitter = Time(MilliSeconds(Period_HelloTx + m_uniformRandomVariable->GetInteger(0, Jitter_HelloTx)));
        Simulator::Schedule(jitter, &RoutingProtocol::SendHello, this);
        SendTo(socket, packet, destination);
      }
      // Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      // std::cout << "Current Node: " << iface.GetAddress() << std::endl;
      //m_neighborsListPointer->GetObject<VbpNeighbors>()->PrintNeighborState();
    }

    void
    RoutingProtocol::SendTo(Ptr<Socket> socket, Ptr<Packet> packet, Ipv4Address destination)
    {
      socket->SendTo(packet, 0, InetSocketAddress(destination, VBP_HELLO_PORT));
    }

    void
    RoutingProtocol::StartHelloTx()
    {
      m_uniformRandomVariable = CreateObject<UniformRandomVariable>();
      Time jitter = Time(MilliSeconds(Period_HelloTx + m_uniformRandomVariable->GetInteger(0, Jitter_HelloTx)));
      Simulator::Schedule(jitter, &RoutingProtocol::SendHello, this);
    }

    std::vector<float>
    RoutingProtocol::GetBroadcastArea()
    {
      return m_broadcastArea;
    }

    void
    RoutingProtocol::SetBroadcastArea(std::vector<float> broadcastArea)
    {
      m_broadcastArea[0] = broadcastArea[0];
      m_broadcastArea[1] = broadcastArea[1];
      m_broadcastArea[2] = broadcastArea[2];
      m_broadcastArea[3] = broadcastArea[3];
    }

    void
    RoutingProtocol::EmptyQueue()
    {
      /*
        Use this function to check queue size
        First check: queue has packets in it
        Second check: A first hop can not be found
        While there are packets in the queue, we check if the queued packets can be sent to a next hop
      */
      NS_LOG_FUNCTION(this);
      Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      Ipv4Address thisVehicleIP = iface.GetAddress();
      NS_LOG_LOGIC("Queue Size at: " << thisVehicleIP << " is " << m_queuePointer->GetObject<VbpQueue>()->GetQueueSize());
      Ipv4Address nextHopAhead;
      Ipv4Address nextHopBehind;
      if (m_queuePointer->GetObject<VbpQueue>()->GetQueueSize() == 0)
      {
        return;
      }
      if (!FindFirstHop(&nextHopAhead, &nextHopBehind))
      {
        return;
      }
      Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
      while (m_queuePointer->GetObject<VbpQueue>()->GetQueueSize() > 0)
      {
        Ipv4Address thisVehicleIP = iface.GetAddress();
        Ptr<const Packet> pkt = m_queuePointer->GetObject<VbpQueue>()->PeekPacket();
        VbpRoutingHeader routingHeader;
        pkt->PeekHeader(routingHeader);

        if (thisVehicleIP == routingHeader.GetPrevHopIP()) // check if first hop
        {
          if (FindFirstHop(&nextHopAhead, &nextHopBehind)) // find next hop
          {
            Ptr<Packet> p = m_queuePointer->GetObject<VbpQueue>()->GetPacket()->Copy();
            Ipv4Header header = m_queuePointer->GetObject<VbpQueue>()->GetHeader();
            Ipv4Address dst = header.GetDestination();
            Ipv4Address src = header.GetSource();
            SetSendFirstHop(&nextHopAhead, &nextHopBehind, p, dev, iface, src, dst);
            if (m_queuePointer->GetObject<VbpQueue>()->GetQueueSize() == 0)
            {
              return;
            }
          }
          else
          {
            return;
          }
        }
        else // this is a forwarding vehicle
        {
          Ptr<Packet> p = m_queuePointer->GetObject<VbpQueue>()->GetPacket()->Copy();
          Ipv4Header header = m_queuePointer->GetObject<VbpQueue>()->GetHeader();
          Ipv4Address dst = header.GetDestination();
          Ipv4Address src = header.GetSource();
          bool packetSentIndicator = false;
          RoutePacket(p, dst, src, &packetSentIndicator);
          if (!packetSentIndicator || (m_queuePointer->GetObject<VbpQueue>()->GetQueueSize() == 0))
          {
            return;
          }
        }
      }
    }

    void
    RoutingProtocol::ScheduleEmptyQueue()
    {
      NS_LOG_FUNCTION(this);
      EmptyQueue();
      Simulator::Schedule(Seconds(m_emptyQueuePeriod), &RoutingProtocol::ScheduleEmptyQueue, this);
    }

    bool
    RoutingProtocol::FindFirstHop(Ipv4Address *nextHopAheadPtr, Ipv4Address *nextHopBehindPtr)
    {
      /*
        FindFirstHop() is called by RouteOutput() to find if there is a first hop available after the packet is generated by the application on the source vehicle
        The first check is to see if the vehicle is moving towards the broadcast area. If so the next hop ahead pointer is found
        If the vehicle is not moving towards the broadcast area then the next hop behind pointer must be updated
        If both next hop ahead and next hop behind addresses are 102.102.102.102 then no nodes exist ahead/behind and no first hop is available
      */
      NS_LOG_FUNCTION(this);
      Vector vehiclePos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
      Vector vehicleVel = m_thisNode->GetObject<MobilityModel>()->GetVelocity();
      float upperLeftBA_x = m_broadcastArea[0];
      float upperLeftBA_y = m_broadcastArea[1];
      float lowerRightBA_x = m_broadcastArea[2];
      float lowerRightBA_y = m_broadcastArea[3];
      Vector centerBA = Vector3D((upperLeftBA_x + lowerRightBA_x) / 2, (upperLeftBA_y + lowerRightBA_y) / 2, 0);
      Vector vehicleToBA = centerBA - vehiclePos;
      bool movingToBA = (vehicleVel.x * vehicleToBA.x + vehicleVel.y * vehicleToBA.y) >= 0; // true if moving towards BA
      if (movingToBA)
      {
        NS_LOG_LOGIC("First hop vehicle moving towards BA");
        nextHopAheadPtr->Set(FindNextHopDownstream(centerBA, movingToBA).Get());
      }
      nextHopBehindPtr->Set(FindNextHopUpstream(centerBA, movingToBA).Get());
      if (*nextHopAheadPtr == Ipv4Address("102.102.102.102") && *nextHopBehindPtr == Ipv4Address("102.102.102.102"))
      {
        NS_LOG_LOGIC("No first hop found, return false");
        return false;
      }
      NS_LOG_LOGIC("First hop found, return true");
      return true;
    }

    Ipv4Address
    RoutingProtocol::FindNextHopDownstream(Vector centerBA, bool movingToBA)
    {
      /*
      FindNextHopDownstream deals with finding a next hop downstream in high, medium and low traffic
      The LOS calculation is compared to quantitative definition for each traffic level. Decides which FindNextHop function to call
      Each FindNextHop function returns an integer value representing the index of the node on the neighbor list.
      This index is used to calculate the neighbor's IP address. This neighbor will be sent a data packet
      */
      NS_LOG_FUNCTION(this);
      if (!movingToBA)
      {
        NS_LOG_LOGIC("Not moving towards broadcast area, return invalid IP address");
        return Ipv4Address("102.102.102.102"); // BA in upstream, not downstream
      }
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighborsAhead(); //get number of downstream neighbors within one-hop
      NS_LOG_LOGIC("Downstream number of neighbors " << numNeighbors);
      if (numNeighbors == 0)
      {
        NS_LOG_LOGIC("No downstream neighbors return invalid IP address");
        return Ipv4Address("102.102.102.102");
      }
      Vector vehiclePos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
      Vector vehicleVel = m_thisNode->GetObject<MobilityModel>()->GetVelocity();
      float LOS = neighborInfo->GetLosCalculation(vehiclePos, vehicleVel); // need to check if neighbor is moving toward broadcast area, if not moving towards bA then ignore
      float stopDist = vehicleVel.GetLength() * 3;                         // stopping distance according to DMV= speed*3 seconds. Distance needed to stop
                                                                           
      int nextHopIdx = -1;
      float neighborhoodSpeed = Vector3D(neighborInfo->GetNeighborHoodSpeedMeanX(), neighborInfo->GetNeighborHoodSpeedMeanY(), 0).GetLength();
      if (LOS > m_vcHighTraffic) // high traffic
      {
        nextHopIdx = FindNextHopHighTrafficDownstream(centerBA, vehiclePos, stopDist);
        NS_LOG_LOGIC("Downstream and high traffic. Index of next hop is: " << nextHopIdx);
        // return node that is closest to broadcast area(Dn)
      }
      else if (LOS < m_vcLowTraffic) // low traffic
      {
        nextHopIdx = FindNextHopLowTrafficDownstream(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
        NS_LOG_LOGIC("Downstream and low traffic. Index of next hop is: " << nextHopIdx);
        NS_LOG_LOGIC("Neighborhood speed: " << neighborhoodSpeed << " center of broadcast area: " << centerBA << " vehicle position: " << vehiclePos << " stopping distance: " << stopDist);
        // return node with MDT
      }
      else // medium traffic
      {
        nextHopIdx = FindNextHopMidTrafficDownstream(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
        NS_LOG_LOGIC("Downstream and medium traffic. Index of next hop is: " << nextHopIdx);
        // return node with smallest Dn and MDT
      }
      if (nextHopIdx >= 0) //index of next hop found
      {
        NS_LOG_LOGIC("Downstream neighbor index found, will get one-hop neighbor's IP address based on index. Neighbor IP address: " << neighborInfo->Get1HopNeighborIP(nextHopIdx));
        return neighborInfo->Get1HopNeighborIP(nextHopIdx);
      }
      return Ipv4Address("102.102.102.102");
    }

    Ipv4Address
    RoutingProtocol::FindNextHopUpstream(Vector centerBA, bool movingToBA)
    {
      /*
      FindNextHopUpstream deals with finding a next hop upstream in high, medium and low traffic. It also considers whether the node is moving towards or away from the broadcast area.
      The LOS calculation is compared to quantitative definition for each traffic level. Decides which FindNextHop function to call
      Each FindNextHop function returns an integer value representing the index of the node on the neighbor list.
      This index is used to calculate the neighbor's IP address. This neighbor will be sent a data packet
      */
      NS_LOG_FUNCTION(this);
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighborsBehind();
      NS_LOG_LOGIC("Upstream number of neighbors: " << numNeighbors);
      if (numNeighbors == 0)
      {
        NS_LOG_LOGIC("No upstream neighbors return invalid IP address");
        return Ipv4Address("102.102.102.102"); // same as receiving node since no neighbors
      }
      Vector vehiclePos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
      Vector vehicleVel = m_thisNode->GetObject<MobilityModel>()->GetVelocity();
      float LOS = neighborInfo->GetLosCalculation(vehiclePos, vehicleVel);
      float stopDist = vehicleVel.GetLength() * 3;
      int nextHopIdx;
      float neighborhoodSpeed = Vector3D(neighborInfo->GetNeighborHoodSpeedMeanX(), neighborInfo->GetNeighborHoodSpeedMeanY(), 0).GetLength();
      if (!movingToBA) //moving away from the broadcast area
      {
        if (LOS > m_vcHighTraffic) //high traffic
        {
          nextHopIdx = FindNextHopHighTrafficUpstreamAwayBA(centerBA, vehiclePos, stopDist);
          NS_LOG_LOGIC("Upstream and high traffic moving away from the broadcast area. Index of next hop is: " << nextHopIdx);
        }
        else if (LOS < m_vcLowTraffic) //low traffic
        {
          nextHopIdx = FindNextHopLowTrafficUpstreamAwayBA(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
          NS_LOG_LOGIC("Upstream and low traffic moving away from the broadcast area. Index of next hop is: " << nextHopIdx);
        }
        else //medium traffic
        {
          nextHopIdx = FindNextHopMidTrafficUpstreamAwayBA(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
          NS_LOG_LOGIC("Upstream and medium traffic moving away from the broadcast area. Index of next hop is: " << nextHopIdx);
        }
      }
      else //moving towards the broadcast area
      {
        // Determine if will reach BA before it expires, return -1 if not closeToBA
        float currentMDT = CalculateDistance(vehiclePos, centerBA) / neighborhoodSpeed;
        if ((Simulator::Now() / 1e9 + Seconds(currentMDT)) <= Seconds(m_BroadcastTime))
        {
          if (LOS > m_vcHighTraffic) //high traffic
          {
            nextHopIdx = FindNextHopHighTrafficUpstreamToBA(centerBA, vehiclePos, stopDist);
            NS_LOG_LOGIC("Upstream and high traffic moving towards from the broadcast area. Index of next hop is: " << nextHopIdx);
          }
          else if (LOS < m_vcLowTraffic) //low traffic
          {
            nextHopIdx = FindNextHopLowTrafficUpstreamToBA(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
            NS_LOG_LOGIC("Upstream and low traffic moving towards from the broadcast area. Index of next hop is: " << nextHopIdx);
          }
          else //medium traffic
          {
            nextHopIdx = FindNextHopMidTrafficUpstreamToBA(neighborhoodSpeed, centerBA, vehiclePos, stopDist);
            NS_LOG_LOGIC("Upstream and medium traffic moving towards from the broadcast area. Index of next hop is: " << nextHopIdx);
          }
        }
        else
        {
          NS_LOG_LOGIC("Find Next Hop Upstream will not reach broadcast area, return invalid IP address");
          return Ipv4Address("102.102.102.102");
        }
      }

      if (nextHopIdx >= 0) //index of next hop found
      {
        NS_LOG_LOGIC("Upstream neighbor index found, will get one-hop neighbor's IP address based on index. Neighbor IP address: " << neighborInfo->Get1HopNeighborIP(nextHopIdx));
        return neighborInfo->Get1HopNeighborIP(nextHopIdx);
      }
      return Ipv4Address("102.102.102.102");
    }

    int
    RoutingProtocol::FindNextHopHighTrafficDownstream(Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in heavy traffic
      // finds next hop based on vehicle closest to broadcast area
      //  high traffic downstream:
      //  movement towards BA: consider neighbors ahead, closest to BA
      //  movement away BA: wont receive -- handled by Rx callback
      NS_LOG_FUNCTION(this << " Next hop based on high traffic downstream, choose neighbor with minimum distance to the broadcast area");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMin = std::numeric_limits<float>::max();
      int furthestIdx = -1;
      float neighborDist;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 0)
        { // car is behind, then skip
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, they are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        NS_LOG_LOGIC("Current min dist is:"<< currentMin << ", best idx is "<< furthestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", Neighbor dist is: " << neighborDist << ", Neighbor dist is: "<< neighborDist);
        if (neighborDist < currentMin)
        {
          // if closer to broadcast area, change current id
          currentMin = neighborDist;
          furthestIdx = idx;
        }
      }
      return furthestIdx;
    }

    int
    RoutingProtocol::FindNextHopMidTrafficDownstream(float neighborHoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in mid traffic
      // finds next hop based on vehicle with Max of sqrt(speed^2 + distToNeighbor^2)
      // Mid traffic downstream:
      // movement towards BA: consider neighbors ahead, Max of sqrt(speed^2 + distToNeighbor^2)
      // movement away BA: wont receive  -- handled by Rx callback
      NS_LOG_FUNCTION(this << " Next hop based on medium traffic downstream, choose neighbor with maximum of sqrt(speed^2 + distToNeighbor^2)");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMax = -1;
      int bestIdx = -1;
      float distToNeighbor;
      float neighborMax;
      float neighborVel;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 0)
        { // car is behind, then skip
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        distToNeighbor = CalculateDistance(neighborPos, vehiclePos);
        if (distToNeighbor < stopDist)
        {
          NS_LOG_LOGIC("Too close, they are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (distToNeighbor >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. they are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        // use most recent measurement speed of individual node
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        neighborMax = std::sqrt(neighborVel * neighborVel + distToNeighbor * distToNeighbor);
        if (neighborMax > currentMax)
        {
          currentMax = neighborMax;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    int
    RoutingProtocol::FindNextHopLowTrafficDownstream(float neighborHoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in low traffic
      // finds next hop based on vehicle with minimum message delivery time
      // Low traffic downstream:
      // movement towards BA : consider neighbors ahead, min MDT
      // movement away BA : wont receive -- handled by Rx callback
      NS_LOG_FUNCTION(this << " Next hop based on low traffic downstream, choose neighbor with minimum MDT");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMDT = std::numeric_limits<float>::max();
      int bestIdx = -1;
      float neighborDist;
      float neighborVel;
      float neighborMDT;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 0)
        { // car is behind, then skip
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        neighborMDT = neighborDist / neighborVel;
        NS_LOG_LOGIC("Current MDT is:"<< currentMDT << ", best idx is "<< bestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", Neighbor dist is: " << neighborDist << ", Neighbor MDT is: "<< neighborMDT);
        if (neighborMDT < currentMDT)
        {
          // if will drive faster to broadcast area, change current id
          currentMDT = neighborMDT;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    int
    RoutingProtocol::FindNextHopHighTrafficUpstreamToBA(Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in heavy traffic
      // finds next hop based on vehicle furthest to broadcast area
      //  High traffic upstream:
      //  movement towards BA : consider neighbors behind, farthest from BA
      //  movement away BA : consider neighbors behind, min Dist to BA
      NS_LOG_FUNCTION(this << " Next hop based on high traffic upstream, choose neighbor with maximum distance to broadcast area");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMax = -1; // if current node closer, hold onto packet
      int furthestIdx = -1;
      float neighborDist;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        NS_LOG_LOGIC("Current dist is:"<< currentMax << ", best idx is "<< furthestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", Neighbor dist is: " << neighborDist << ", Neighbor dist is: "<< neighborDist);
        if (neighborDist > currentMax)
        {
          // if closer to broadcast area, change current id
          currentMax = neighborDist;
          furthestIdx = idx;
        }
      }
      return furthestIdx;
    }

    int
    RoutingProtocol::FindNextHopHighTrafficUpstreamAwayBA(Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in heavy traffic
      // finds next hop based on vehicle min Dist to BA
      //  High traffic upstream:
      //  movement towards BA : consider neighbors behind, farthest from BA
      //  movement away BA : consider neighbors behind, min Dist to BA
      NS_LOG_FUNCTION(this << " Next hop based on high traffic upstream (away from broadcast area), choose neighbor minimum dist to broadcast area");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMin = std::numeric_limits<float>::max(); // if current node closer, hold onto packet
      int furthestIdx = -1;
      float neighborDist;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip, only change from high traffic
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        NS_LOG_LOGIC("Current dist is:"<< currentMin << ", best idx is "<< furthestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", Neighbor dist is: " << neighborDist << ", Neighbor dist is: "<< neighborDist);
        if (neighborDist < currentMin)
        {
          // if closer to broadcast area, change current id
          currentMin = neighborDist;
          furthestIdx = idx;
        }
      }
      return furthestIdx;
    }

    int
    RoutingProtocol::FindNextHopMidTrafficUpstreamToBA(float neighborhoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in mid traffic
      // finds next hop based on vehicle with Max of sqrt(MDT^2 + distToNeighbor^2)
      // Mid traffic upstream:
      // movement towards BA : consider neighbors behind, Max of sqrt(MDT^2 + distToNeighbor^2)
      // movement away BA : consider neighbors behind, min of sqrt(speed^2 + distToNeighborToBA^2)
      NS_LOG_FUNCTION(this << "Next hop based on medium traffic upstream (towards broadcast area), choose neighbor with maximum of sqrt(MDT^2 + distToNeighbor^2)");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMax = -1;
      int bestIdx = -1;
      float neighborMDT;
      float neighborMax;
      float neighborVel;
      float neighborDist;
      float distToNeighbor;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip, only change from high traffic
          continue;
        }
        // wil include vehicles ahead and behind in case they have max MDT
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        distToNeighbor = CalculateDistance(neighborPos, vehiclePos);
        if (distToNeighbor < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (distToNeighbor >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        neighborMDT = neighborDist / neighborVel;
        neighborMax = std::sqrt(neighborMDT * neighborMDT + distToNeighbor * distToNeighbor);
        NS_LOG_LOGIC("Current Max is:" << currentMax << ", best idx is "<< bestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", dist To Neighbor is: " << distToNeighbor << ", Neighbor Max is: " << neighborMax);
        if (neighborMax > currentMax)
        {
          currentMax = neighborMax;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    int
    RoutingProtocol::FindNextHopMidTrafficUpstreamAwayBA(float neighborhoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in mid traffic
      // finds next hop based on vehicle with min of sqrt(speed^2 + distNeighborToBA^2)
      // Mid traffic upstream:
      // movement towards BA : consider neighbors behind, Max of sqrt(MDT^2 + distToNeighbor^2)
      // movement away BA : consider neighbors behind, min of sqrt(speed^2 + distNeighborToBA^2)
      NS_LOG_FUNCTION(this << "Next hop based on medium traffic upstream (away from broadcast area), choose neighbor with minimum of sqrt(speed^2 + distToNeighborToBA^2)");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMin = std::numeric_limits<float>::max();
      int bestIdx = -1;
      float neighborDist;
      float neighborVel;
      float neighborMin;
      float distToNeighbor;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip, only change from high traffic
          continue;
        }
        // wil include vehicles ahead and behind in case they have max MDT
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        distToNeighbor = CalculateDistance(neighborPos, vehiclePos);
        if (distToNeighbor < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (distToNeighbor >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue;
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        neighborMin = std::sqrt(neighborVel * neighborVel + neighborDist * neighborDist);
        NS_LOG_LOGIC("Current Min is:" << currentMin << ", best idx is "<< bestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx << ", dist To Neighbor is: " << distToNeighbor << ", Neighbor Min is: " << neighborMin);
        if (neighborMin < currentMin)
        {
          // if (neighborInfo->Get1HopNumberOfNodesBehindOfNeighbor(idx) == 0) {
          //  if node doesn't have neighbors ahead, move on
          //  continue;
          //}
          currentMin = neighborMin;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    int
    RoutingProtocol::FindNextHopLowTrafficUpstreamToBA(float neighborhoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in low traffic
      // finds next hop based on vehicle with maximum message delivery time
      // Low traffic upstream:
      // movement towards BA : consider neighbors behind, max MDT
      // movement away BA : consider neighbors behind, min speed
      NS_LOG_FUNCTION(this << "Next hop based on low traffic upstream (towards broadcast area), choose neighbor with maximum MDT");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentMDT = -1;
      int bestIdx = -1;
      float neighborDist;
      float neighborVel;
      float neighborMDT;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        // will consider vehicles going behind, change from low traffic
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip,only change from high traffic
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue;
        }
        neighborDist = CalculateDistance(neighborPos, centerBA);
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        neighborMDT = neighborDist / neighborVel;
        NS_LOG_LOGIC("Current MDT is:"<< currentMDT << ", best idx is "<< bestIdx);
        NS_LOG_LOGIC("Neighbor id is: "<< neighborInfo->Get1HopNeighborIP(idx) << ", idx is: " << idx);
        NS_LOG_LOGIC(", Neighbor dist is: " << neighborDist << ", Neighbor MDT is: "<< neighborMDT);
        if (neighborMDT > currentMDT)
        {
          currentMDT = neighborMDT;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    int
    RoutingProtocol::FindNextHopLowTrafficUpstreamAwayBA(float neighborhoodSpeed, Vector centerBA, Vector vehiclePos, float stopDist)
    {
      // used in low traffic
      // finds next hop based on vehicle with minimum speed
      // Low traffic upstream:
      // movement towards BA : consider neighbors behind, max MDT
      // movement away BA : consider neighbors behind, min speed
      NS_LOG_FUNCTION(this << "Next hop based on low traffic upstream (away from broadcast area), choose neighbor with minimum speed");
      Ptr<VbpNeighbors> neighborInfo = m_neighborsListPointer->GetObject<VbpNeighbors>();
      uint16_t numNeighbors = neighborInfo->Get1HopNumNeighbors();
      float currentSpeed = std::numeric_limits<float>::max();
      int bestIdx = -1;
      float neighborVel;
      Vector neighborPos;
      for (uint16_t idx = 0; idx < numNeighbors; idx++)
      {
        // will consider vehicles going behind
        if (neighborInfo->Get1HopDirection(idx) == 1)
        { // car is ahead, then skip
          continue;
        }
        neighborPos = Vector3D(neighborInfo->GetNeighborPositionX(idx), neighborInfo->GetNeighborPositionY(idx), 0);
        if (CalculateDistance(neighborPos, vehiclePos) < stopDist)
        {
          NS_LOG_LOGIC("Too close, They are  within(m): " << stopDist);
          continue; // if not going to move more than 3 second of driving, hold onto packet
        }
        if (CalculateDistance(neighborPos, vehiclePos) >= m_maxDistance * m_txCutoffPercentage)
        {
          NS_LOG_LOGIC("Too far, may not make it to them. They are  within(m): " << m_maxDistance * m_txCutoffPercentage);
          continue;
        }
        neighborVel = Vector3D(neighborInfo->GetNeighborSpeedX(idx), neighborInfo->GetNeighborSpeedY(idx), 0).GetLength();
        NS_LOG_LOGIC("Current speed is:" << currentSpeed << ", best idx is " << bestIdx);
        NS_LOG_LOGIC("Neighbor speed is: " << neighborVel);
        if (neighborVel <= currentSpeed)
        {
          // if will drive slower, change current id
          currentSpeed = neighborVel;
          bestIdx = idx;
        }
      }
      return bestIdx;
    }

    Ptr<Ipv4Route>
    RoutingProtocol::LoopbackRoute(const Ipv4Header &hdr, Ptr<NetDevice> oif) const
    {
      // This is the same LoopbackRoute implemented in AODV
      NS_LOG_FUNCTION(this << hdr);
      NS_ASSERT(m_lo != 0);

      Ptr<Ipv4Route> routePtr; // = Create<Ipv4Route> ();
      RoutingTableEntry rt;
      rt.SetNextHop(Ipv4Address("127.0.0.1"));
      rt.SetOutputDevice(m_lo);
      routePtr = rt.GetRoute();
      routePtr->SetDestination(hdr.GetDestination());
      //
      // Source address selection here is tricky.  The loopback route is
      // returned when AODV does not have a route; this causes the packet
      // to be looped back and handled (cached) in RouteInput() method
      // while a route is found. However, connection-oriented protocols
      // like TCP need to create an endpoint four-tuple (src, src port,
      // dst, dst port) and create a pseudo-header for checksumming.  So,
      // AODV needs to guess correctly what the eventual source address
      // will be.
      //
      // For single interface, single address nodes, this is not a problem.
      // When there are possibly multiple outgoing interfaces, the policy
      // implemented here is to pick the first available AODV interface.
      // If RouteOutput() caller specified an outgoing interface, that
      // further constrains the selection of source address
      //
      std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j = m_socketAddresses.begin();
      if (oif)
      {
        // Iterate to find an address on the oif device
        for (j = m_socketAddresses.begin(); j != m_socketAddresses.end(); ++j)
        {
          Ipv4Address addr = j->second.GetLocal();
          int32_t interface = m_ipv4->GetInterfaceForAddress(addr);
          if (oif == m_ipv4->GetNetDevice(static_cast<uint32_t>(interface)))
          {
            routePtr->SetSource(addr);
            break;
          }
        }
      }
      else
      {
        routePtr->SetSource(j->second.GetLocal());
      }
      NS_ASSERT_MSG(routePtr->GetSource() != Ipv4Address(), "Valid VBP source address not found");
      routePtr->SetGateway(Ipv4Address("127.0.0.1"));
      routePtr->SetOutputDevice(m_lo);
      return routePtr;
    }

    void
    RoutingProtocol::DeferredRouteOutput(Ptr<const Packet> p, const Ipv4Header &header,
                                         UnicastForwardCallback ucb, ErrorCallback ecb)
    {
      // This is the same DeferredRouteOutput as AODV
      // Append all params DeferredRouteOutput receives packet, header, ucb, ecb
      // Check how aodv removes packets from queue. If packet is removed, next hop has been found. Guessing ucb is called. Confirm.
      NS_LOG_FUNCTION(this << p << header);
      NS_ASSERT(p != 0 && p != Ptr<Packet>());
      // check if queue full. If full, can not append. If not full, append.
      if (m_queuePointer->GetObject<VbpQueue>()->QueueFull())
      {
        NS_LOG_LOGIC("Queue full");
        Ptr<const Packet> p = m_queuePointer->GetObject<VbpQueue>()->GetPacket();
        Ipv4Header header = m_queuePointer->GetObject<VbpQueue>()->GetHeader();
        Ipv4RoutingProtocol::ErrorCallback ecb = m_queuePointer->GetObject<VbpQueue>()->GetEcb();
        ecb(p, header, Socket::ERROR_NOTERROR);
      }
      NS_LOG_LOGIC("Queue not full, append packet and header");
      m_queuePointer->GetObject<VbpQueue>()->AppendPacket(p);
      m_queuePointer->GetObject<VbpQueue>()->AppendHeader(header);
    }

    bool
    RoutingProtocol::FindNextHop(Ipv4Address *nextHopAheadPtr, Ipv4Address *nextHopBehindPtr, Vector centerBA, bool movingToBA, bool closeToBA, bool *enqueuePacketIndicator, Ipv4Address prevHopIP)
    {
      /*
      FindNextHop() will return true if a next hop is available, otherwise false.
      Two cases are considered: packet is sent from behind or packet is sent from ahead
      enqueuePacketIndicator returns true when the packet is queued, otherwise false because the packet will be sent to a next hop
      */
      NS_LOG_FUNCTION(this);
      *nextHopAheadPtr = Ipv4Address("102.102.102.102");
      *nextHopBehindPtr = Ipv4Address("102.102.102.102");
      if (m_neighborsListPointer->GetObject<VbpNeighbors>()->Get1HopDirectionByIP(prevHopIP) == 0) // packet sent from behind. send downstream
      {
        *nextHopAheadPtr = FindNextHopDownstream(centerBA, movingToBA);
        if (*nextHopAheadPtr == Ipv4Address("102.102.102.102"))
        {
          Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
          NS_LOG_LOGIC("enqueuePacketIndicator true and packet will be locally delivered at this address: " << iface.GetAddress() << " previous hop: " << prevHopIP << " direction: " << m_neighborsListPointer->GetObject<VbpNeighbors>()->Get1HopDirectionByIP(prevHopIP));
          *enqueuePacketIndicator = true;
          return false;
        }
        return true;
      }
      else // previous hop is from ahead
      {
        if (closeToBA)
        {
          *nextHopBehindPtr = FindNextHopUpstream(centerBA, movingToBA);
          if (*nextHopBehindPtr == Ipv4Address("102.102.102.102"))
          {
            Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
            NS_LOG_LOGIC("enqueuePacketIndicator true and packet will be locally delivered at this address: " << iface.GetAddress());
            *enqueuePacketIndicator = true;
            return false;
          }
          *enqueuePacketIndicator = false;
          return true;
        }
        else
        {
          NS_LOG_LOGIC("Will stop sending upstream because vehicle won't reach BA before expiration");
          *enqueuePacketIndicator = false;
          return false;
        }
      }
    }

    bool
    RoutingProtocol::RoutePacket(Ptr<Packet> p, Ipv4Address dst, Ipv4Address src, bool *packetSentIndicator)
    {
      /*
        RoutePacket() returns true if a case is found where the packet can reach the broadcast area before the BA expires.
        Case 1: vehicle in the broadcast area already
        Case 2: vehicle not in the broadcast area and will likely reach the BA before expiration
        Case 3: vehicle needs to forward node to a vehicle that is more likely to reach the broadcast area before expiration
        RoutePacket() is called by EmptyQueue() and RouteInput()

      */
      NS_LOG_FUNCTION(this);
      *packetSentIndicator = false;
      Vector vehiclePos = m_thisNode->GetObject<MobilityModel>()->GetPosition();
      Ptr<VbpNeighbors> neighborsList = m_neighborsListPointer->GetObject<VbpNeighbors>();
      // case 1: vehicle already in broadcast area
      VbpRoutingHeader routingHeader;
      p->PeekHeader(routingHeader);
      // std::cout << "Print Packet \n"
      //           << std::endl;
      // p->Print(std::cout);
      // std::cout << "Print Packet END \n"
      //           << std::endl;
      NS_LOG_LOGIC("RoutePacket Prev Hop IP: " << routingHeader.GetPrevHopIP());
      NS_LOG_LOGIC("RoutePacket Packet Type: " << routingHeader.GetPacketType());
      // Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      // std::cout << "\n" << std::endl;
      // std::cout << "This vehicle (IP address): " << iface.GetLocal() << std::endl;
      // std::cout << "---Begin Data Packet Header Information---" << std::endl;
      // std::cout << "Packet type: " << routingHeader.GetPacketType() << std::endl;
      // std::cout << "Previous hop (IP address): " << routingHeader.GetPrevHopIP() << std::endl;
      // std::cout << "BA X-pos (upper left): " << routingHeader.GetPosition1X() << std::endl;
      // std::cout << "BA Y-pos (upper left): " << routingHeader.GetPosition1Y() << std::endl;
      // std::cout << "BA X-pos (bottom right): " << routingHeader.GetPosition2X() << std::endl;
      // std::cout << "BA Y-pos (bottom right): " << routingHeader.GetPosition2Y() << std::endl;
      // std::cout << "BA expiration time: " << routingHeader.GetBroadcastingTime() << std::endl;
      // std::cout << "---End Data Packet Header Information---" << std::endl;
      if ((routingHeader.GetPosition1X() <= vehiclePos.x) && (vehiclePos.x <= routingHeader.GetPosition2X()))
      {
        NS_LOG_LOGIC("RoutePacket Case 1: Vehicle already in the broadcast area ");
        if ((routingHeader.GetPosition1Y() <= vehiclePos.y) && (vehiclePos.y <= routingHeader.GetPosition2Y()))
        {
          p->RemoveHeader(routingHeader);
          return true; // true = lcb
        }
      }
      // case 2: vehicle not in BA and may reach BA before expiration
      Vector BA1 = Vector3D(routingHeader.GetPosition1X(), routingHeader.GetPosition1Y(), 0); // for broadcast area point one
      Vector BA2 = Vector3D(routingHeader.GetPosition2X(), routingHeader.GetPosition2Y(), 0); // for broadcast area point two
      Vector centerBA = Vector3D((BA1.x + BA2.x) / 2, (BA1.y + BA2.y) / 2, 0);
      float neighborhoodSpeed = Vector3D(neighborsList->GetNeighborHoodSpeedMeanX(), neighborsList->GetNeighborHoodSpeedMeanY(), 0).GetLength();
      float currentMDT = CalculateDistance(vehiclePos, centerBA) / neighborhoodSpeed;
      bool closeToBA = false;
      Ptr<Packet> q = p->Copy();
      if ((Simulator::Now() / 1e9 + Seconds(currentMDT)) <= Seconds(m_BroadcastTime))
      {
        NS_LOG_LOGIC("RoutePacket Case 2: Vehicle not in the broadcast area and may reach the BA before expiration");
        p->RemoveHeader(routingHeader);
        closeToBA = true; // will need to return closeToBA after forwarding. return true
      }
      bool enqueuePacketIndicator = false;
      Ipv4Address prevHopIP = routingHeader.GetPrevHopIP();
      Vector vehicleVel = m_thisNode->GetObject<MobilityModel>()->GetVelocity();
      Vector vehicleToBA = centerBA - vehiclePos;
      bool movingToBA = (vehicleVel.x * vehicleToBA.x + vehicleVel.y * vehicleToBA.y) >= 0; // true if moving towards BA
      Ipv4Address nextHopAhead;
      Ipv4Address nextHopBehind;
      // case 3: use FindNextHop to route packet
      if (FindNextHop(&nextHopAhead, &nextHopBehind, centerBA, movingToBA, closeToBA, &enqueuePacketIndicator, prevHopIP))
      {
        NS_LOG_LOGIC("RoutePacket Case 3: Use FindNextHop() to route packet");
        Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
        Ptr<NetDevice> dev = m_ipv4->GetNetDevice(m_ipv4->GetInterfaceForAddress(iface.GetLocal()));
        RoutingTableEntry rt;
        rt.SetOutputDevice(dev);
        rt.SetInterface(iface);
        Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
        Ipv4Address thisVehicleIP = iface.GetAddress();
        q->RemoveHeader(routingHeader);
        routingHeader.SetData(m_dataPacketType, thisVehicleIP, routingHeader.GetPosition1X(), routingHeader.GetPosition1Y(), routingHeader.GetPosition2X(), routingHeader.GetPosition2Y(), routingHeader.GetBroadcastingTime());
        q->AddHeader(routingHeader);
        if (nextHopAhead != Ipv4Address("102.102.102.102"))
        {
          NS_LOG_LOGIC("Route Packet Case 3: Next Hop Ahead Only");
          Ptr<Ipv4Route> routeDownstream;
          rt.SetNextHop(nextHopAhead);
          routeDownstream = rt.GetRoute();
          l3->Send(q, src, dst, PROT_NUMBER, routeDownstream);
          *packetSentIndicator = true;
        }
        else
        {
          NS_LOG_LOGIC("Route Packet Case 3: Next Hop Behind Only");
          Ptr<Ipv4Route> routeUpstream;
          rt.SetNextHop(nextHopBehind);
          routeUpstream = rt.GetRoute();
          l3->Send(q, src, dst, PROT_NUMBER, routeUpstream);
          *packetSentIndicator = true;
        }
      }
      Ipv4InterfaceAddress iface = m_socketAddresses.begin()->second;
      NS_LOG_LOGIC("enqueuePacketIndicator " << enqueuePacketIndicator << " at " << iface.GetLocal());
      if (enqueuePacketIndicator)
      {
        NS_LOG_LOGIC("Packet will be queued at " << iface.GetLocal());
        m_queuePointer->GetObject<VbpQueue>()->AppendPacket(q);
        Ipv4Header header;
        m_queuePointer->GetObject<VbpQueue>()->AppendHeader(header);
      }
      return closeToBA;
    }

    void
    RoutingProtocol::SetSendFirstHop(Ipv4Address *nextHopAheadPtr, Ipv4Address *nextHopBehindPtr, Ptr<Packet> p, Ptr<NetDevice> dev, Ipv4InterfaceAddress iface, Ipv4Address src, Ipv4Address dst)
    {
      /*
        This function is called in RouteOutput() and EmptyQueue(). It sets the route and calls Ipv4L3Protocol to send the packet
        Three cases considered: next hop is ahead and behind, next hop is ahead or next hop is behind
        If next hop is ahead and behind the packet is duplicated so the original and copy can be sent in both directions
      */
      RoutingTableEntry rt;
      rt.SetOutputDevice(dev);
      rt.SetInterface(iface);
      Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol>();
      if (*nextHopAheadPtr != Ipv4Address("102.102.102.102") && *nextHopBehindPtr != Ipv4Address("102.102.102.102")) // case: hops both ahead and behind
      {
        NS_LOG_LOGIC("Next Hop Ahead and Behind");
        // next hop ahead
        Ptr<Ipv4Route> routeDownstream;
        rt.SetNextHop(*nextHopAheadPtr);
        routeDownstream = rt.GetRoute();
        l3->Send(p, src, dst, PROT_NUMBER, routeDownstream);
        // next hop behind
        Ptr<Packet> q = p->Copy();
        Ptr<Ipv4Route> routeUpstream;
        rt.SetNextHop(*nextHopBehindPtr);
        routeUpstream = rt.GetRoute();
        l3->Send(q, src, dst, PROT_NUMBER, routeUpstream);
      }
      else if (*nextHopAheadPtr != Ipv4Address("102.102.102.102"))
      {
        NS_LOG_LOGIC("Next Hop Ahead Only");
        Ptr<Ipv4Route> routeDownstream;
        rt.SetNextHop(*nextHopAheadPtr);
        routeDownstream = rt.GetRoute();
        l3->Send(p, src, dst, PROT_NUMBER, routeDownstream);
      }
      else
      {
        NS_LOG_LOGIC("Next Hop Behind Only");
        Ptr<Ipv4Route> routeUpstream;
        rt.SetNextHop(*nextHopBehindPtr);
        routeUpstream = rt.GetRoute();
        l3->Send(p, src, dst, PROT_NUMBER, routeUpstream);
      }
    }

  } // namespace vbp
} // namespace ns3